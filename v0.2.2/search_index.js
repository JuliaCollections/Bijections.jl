var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following methods constitute the public API of the Bijections package.","category":"page"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Reference","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/#Bijections.Bijection-Tuple{}","page":"API","title":"Bijections.Bijection","text":"Bijection()\n\nConstruct a new Bijection. \n\nBijection{S,T}() creates an empty Bijection from objects of type S to objects of type T. If S and T are omitted, then we have Bijection{Any,Any}.\nBijection(x::S, y::T) creates a new Bijection initialized with x mapping to y.\nBijection(dict::Dict{S,T}) creates a new Bijection based on the mapping in dict. \nBijection(pair_list::Vector{Pair{S,T}}) creates a new Bijection using the key/value pairs in pair_list. \n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Union{Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Bijection{B, A}, Bijection{C, B}}} where {A, B, C}","page":"API","title":"Base.:*","text":"(*)(a::Bijection{A,B}, b::Bijection{B,C})::Bijection{A,C} where {A,B,C}\n\nThe result of a * b is a new Bijection c such that c[x] is a[b[x]] for x in the domain of b. This function throws an error is domain(a) is not the same  as the image of b.    \n\n\n\n\n\n","category":"method"},{"location":"api/#Base.delete!-Tuple{Bijection, Any}","page":"API","title":"Base.delete!","text":"delete!(b::Bijection, x)\n\nDeletes the ordered pair (x,b[x]) from b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.get-Tuple{Bijection, Any, Any}","page":"API","title":"Base.get","text":"get(b::Bijection, key, default)\n\nReturns b[key] if it exists and returns default otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Bijection, Any}","page":"API","title":"Base.getindex","text":"getindex(b::Bijection, x)\n\nFor a Bijection b and a value x in its domain, use b[x] to fetch the image value y associated with x.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Tuple{Bijection, Any}","page":"API","title":"Base.haskey","text":"Base.haskey(b::Bijection, x)\n\nChecks if x is in the domain of the Bijection b.`\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.inv-Tuple{Bijection}","page":"API","title":"Base.inv","text":"inv(b::Bijection)\n\nCreates a new Bijection that is the inverse of b. Subsequence changes to b will not affect inv(b).\n\nSee also active_inv.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isempty-Tuple{Bijection}","page":"API","title":"Base.isempty","text":"isempty(b::Bijection)\n\nReturns true iff b has no pairs.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{Bijection}","page":"API","title":"Base.length","text":"length(b::Bijection)\n\nGives the number of ordered pairs in b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{Bijection, Any, Any}","page":"API","title":"Base.setindex!","text":"setindex!(b::Bijection, y, x)\n\nFor a Bijection b use the syntax b[x]=y to add (x,y) to b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bijections.active_inv-Tuple{Bijection}","page":"API","title":"Bijections.active_inv","text":"active_inv(b::Bijection)\n\nCreates a Bijection that is the inverse of b. The original b and the new Bijection returned are tied together so that changes to one immediately affect the other. In this way, the two Bijections remain inverses in perpetuity.\n\nSee also inv.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bijections.domain-Tuple{Bijection}","page":"API","title":"Bijections.domain","text":"domain(b::Bijection)\n\nReturns an iterator for the keys for b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bijections.hasvalue-Tuple{Bijection, Any}","page":"API","title":"Bijections.hasvalue","text":"hasvalue(b::Bijection, y)\n\nChecks if y is in the image of the Bijection b. It is equivalent to checking if the inverse mapping b.finv has y as a key, so it should as fast as haskey.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bijections.image-Tuple{Bijection}","page":"API","title":"Bijections.image","text":"image(b::Bijection)\n\nReturns an iterator for the values of b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bijections.inverse-Tuple{Bijection, Any}","page":"API","title":"Bijections.inverse","text":"inverse(b::Bijection, y)\n\nReturns the value x such that b[x] == y (if it exists).\n\n\n\n\n\n","category":"method"},{"location":"api/#Bijections.inverse_dict_type-Union{Tuple{Type{<:AbstractDict{K, V}}}, Tuple{V}, Tuple{K}} where {K, V}","page":"API","title":"Bijections.inverse_dict_type","text":"inverse_dict_type(D::Type{<:AbstractDict})\n\nReturns the type of the inverse dictionary for a given AbstractDict type D. This is used internally to create the inverse mapping in a Bijection.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Using-Bijections","page":"Using Bijections","title":"Using Bijections","text":"","category":"section"},{"location":"usage/#Adding-and-deleting-key/value-pairs","page":"Using Bijections","title":"Adding and deleting key/value pairs","text":"","category":"section"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"Once a Bijection, b, is created, we add a new key-value pair in the same manner as with a Dict:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"julia> b = Bijection{Int, String}();\n\njulia> b[1] = \"hello\"\n\"hello\"\n\njulia> b[2] = \"bye\"\n\"bye\"","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"Notice, however, that if we add a new key with a value that already exists in the Bijection an error ensues:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"julia> b[3] = \"hello\"\nERROR: One of x or y already in this Bijection","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"Likewise, if a key already has a value it cannot be changed by giving it a new value:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"julia> b[1] = \"ciao\"\nERROR: One of x or y already in this Bijection","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"If we wish to change the value associated with a given key, the pair must first be deleted using delete!:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"julia> delete!(b,1)\nBijection{Int64, String, Dict{Int64, String}, Dict{String, Int64}} with 1 entry:\n  2 => \"bye\"\n\njulia> b[1] = \"ciao\"\n\"ciao\"","category":"page"},{"location":"usage/#Accessing-values-from-keys,-and-keys-from-values","page":"Using Bijections","title":"Accessing values from keys, and keys from values","text":"","category":"section"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"To access a value associated with a given key, we use the same syntax as for a Dict:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"julia> b[1]\n\"ciao\"\n\njulia> b[2]\n\"bye\"","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"If the key is not in the Bijection an error is raised:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"julia> b[3]\nERROR: KeyError: 3 not found","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"Since the values in a Bijection must be distinct, we can give a value as an input and retrieve its associate key. The function inverse(b,y) finds the value x such that b[x]==y. However, we provide the handy short cut b(y):","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"julia> b(\"bye\")\n2\n\njulia> b(\"ciao\")\n1","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"Naturally, if the requested value is not in the Bijection an error is raised:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"julia> b(\"hello\")\nERROR: KeyError: hello not found","category":"page"},{"location":"usage/#Inspection","page":"Using Bijections","title":"Inspection","text":"","category":"section"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"Thinking of a Bijection as a mapping between finite sets, we provide the functions domain and image. These return, respectively, iterators for the keys and the values of the Bijection.","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"julia> domain(b)\nKeySet for a Dict{Int64, String} with 2 entries. Keys:\n  2\n  1\n\njulia> image(b)\nValueIterator for a Dict{Int64, String} with 2 entries. Values:\n  \"bye\"\n  \"ciao\"","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"The collect function returns the Bijection as an array of key-value pairs:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"julia> collect(b)\n2-element Array{Tuple{Any,Any},1}:\n (2,\"bye\")\n (1,\"ciao\")","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"The length function returns the number of key-value pairs:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"julia> length(b)\n2","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"The isempty function returns true exactly when the Bijection contains no pairs:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"julia> isempty(b)\nfalse","category":"page"},{"location":"#Bijections","page":"Getting Started","title":"Bijections","text":"","category":"section"},{"location":"#Overview","page":"Getting Started","title":"Overview","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Mathematically, a bijection is a one-to-one and onto function between sets. In this module, we provide the Bijection data type that represents a bijection between finite collections of objects.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"A Dict in Julia is not one-to-one. Two different keys might have the same value. A Bijection data structure behaves just like a Dict except that it prevents assigning the same value to two different keys.","category":"page"},{"location":"#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"After using Bijections we create a new Bijection in one of the following ways:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"b = Bijection(): This gives a new Bijection in which the keys and values are of Any type.\nb = Bijection{S,T}(): This gives a new Bijection in which the keys are of type S and the values are of type T.\nb = Bijection(x,y): This gives a new Bijection in which the keys are type typeof(x), the values are type typeof(y) and the key-value pair (x,y) is inserted into the Bijection.\nb = Bijection(dict::AbstractDict{S, T}): This gives a new Bijection in which the keys are type S, the values are type T and all key-value pairs in dict are inserted into the Bijection.\nb = Bijection(pair_list::Vector{Pair{S, T}}): Create a new Bijection using a list of pairs.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"See also the Mutable Objects page for additional constructor options.","category":"page"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations/#Creating-an-inverse-Bijection","page":"Operations","title":"Creating an inverse Bijection","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"There are two functions that take a Bijection and return a new Bijection that is the functional inverse of the original: inv and active_inv.","category":"page"},{"location":"operations/#Independent-inverse:-inv","page":"Operations","title":"Independent inverse: inv","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Given a Bijection b, calling inv(b) creates a new Bijection that is the inverse of b. The new Bijection is completely independent of the original, b. Changes to one do not affect the other:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> b = Bijection{Int,String}()\nBijection Dict{Int64, String}()\n\njulia> b[1] = \"alpha\"\n\"alpha\"\n\njulia> b[2] = \"beta\"\n\"beta\"\n\njulia> bb = inv(b)\nBijection Dict{String, Int64} with 2 entries:\n  \"alpha\" => 1\n  \"beta\"  => 2\n\njulia> bb[\"alpha\"]\n1\n\njulia> bb[\"alpha\"]\n1\n\njulia> b[3] = \"gamma\"\n\"gamma\"\n\njulia> bb[\"gamma\"]\nERROR: KeyError: key \"gamma\" not found","category":"page"},{"location":"operations/#Active-inverse:-active_inv","page":"Operations","title":"Active inverse: active_inv","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The active_inv function also creates an inverse Bijection, but in this case the original and the inverse are actively tied together. That is, modification of one immediately affects the other. The two Bijections remain inverses no matter how either is modified.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> b = Bijection{Int,String}()\nBijection Dict{Int64, String}()\n\njulia> b[1] = \"alpha\"\n\"alpha\"\n\njulia> b[2] = \"beta\"\n\"beta\"\n\njulia> bb = active_inv(b)\nBijection Dict{String, Int64} with 2 entries:\n  \"alpha\" => 1\n  \"beta\"  => 2\n\njulia> b[3] = \"gamma\"\n\"gamma\"\n\njulia> bb[\"gamma\"]\n3","category":"page"},{"location":"operations/#Iteration","page":"Operations","title":"Iteration","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Bijections can be used in a for statement just like Julia dictionaries:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> for (x,y) in b; println(\"$x --> $y\"); end\n2 --> beta\n3 --> gamma\n1 --> alpha","category":"page"},{"location":"operations/#Composition","page":"Operations","title":"Composition","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Given two Bijections a and b, their composition c = a*b is a new Bijection with the property that c[x] = a[b[x]] for all x in the domain of b.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> a = Bijection{Int,Int}(); a[1] = 10; a[2] = 20;\n\njulia> b = Bijection{String,Int}(); b[\"hi\"] = 1; b[\"bye\"] = 2;\n\njulia> c = a * b;\n\njulia> c[\"hi\"]\n10","category":"page"},{"location":"mutable/#mutable","page":"Mutable Objects","title":"Bijections for Mutable Structures","text":"","category":"section"},{"location":"mutable/#Mutating-keys/values-can-lead-to-corruption","page":"Mutable Objects","title":"Mutating keys/values can lead to corruption","text":"","category":"section"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"The safest use of a Bijection is when the keys and values  are immutable. If a mutable key or value in a Bijection is altered, the bijective property can be compromised. Here is an example:","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"julia> b = Bijection{Int, Vector{Int}}();\n\njulia> b[1] = [1,2,3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> b[2] = [1,2,4]\n3-element Vector{Int64}:\n 1\n 2\n 4\n\njulia> b[2][3] = 3\n3\n\njulia> b\nBijection{Int64, Vector{Int64}, Dict{Int64, Vector{Int64}}, Dict{Vector{Int64}, Int64}} with 2 entries:\n  2 => [1, 2, 3]\n  1 => [1, 2, 3]","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"Notice that b contains a repeated value and therefore is not bijective.","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"Some strategies to avoid this problem include:","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"Only use immutable keys and values (such as numbers and strings).\nUse copies of the keys/values in the Bijection.\nDon't modify keys/values saved in the Bijection.","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"In case none of these is a viable option, we provide the following additional alternative.","category":"page"},{"location":"mutable/#Keys/values-as-objects","page":"Mutable Objects","title":"Keys/values as objects","text":"","category":"section"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"The issue in the example presented above is that distinct Julia objects may be equal, but not the same object. For example:","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"julia> v = [1,2,3];\n\njulia> w = [1,2,3];\n\njulia> v==w\ntrue\n\njulia> v===w\nfalse","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"We may wish to create a Bijection in which the keys or values are permitted to be equal, but are distinct objects. Julia's IdDict is a variation of Dict in which keys/values are considered different if they are distinct object (even if they hold the same data). To replicate this behavior in a Bijection use this longer form constructor:","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"Bijection{K, V, IdDict{K,V}, IdDict{V,K}}()","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"where K is the type of the keys and V is the type of the values.","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"For example:","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"julia> b = Bijection{Vector{Int}, String, IdDict{Vector{Int},String}, IdDict{String,Vector{Int}}}();\n\njulia> b[ [1,2,3] ] = \"alpha\";\n\njulia> b[ [1,2,3] ] = \"beta\";\n\njulia> b(\"alpha\") == b(\"beta\")\ntrue\n\njulia> b(\"alpha\") === b(\"beta\")\nfalse\n\njulia> domain(b)\nKeySet for a IdDict{Vector{Int64}, String} with 2 entries. Keys:\n  [1, 2, 3]\n  [1, 2, 3]\n\njulia> Set(domain(b))\nSet{Vector{Int64}} with 1 element:\n  [1, 2, 3]","category":"page"}]
}

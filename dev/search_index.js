var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"The following methods constitute the public API of the Bijections package.","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/#Reference","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/#Bijections.Bijection-Tuple{}","page":"API","title":"Bijections.Bijection","text":"Bijection()\n\nConstruct a new Bijection.\n\nBijection{S,T}() creates an empty Bijection from objects of type S to objects of type T. If S and T are omitted, then we have Bijection{Any,Any}.\nBijection(x::S, y::T) creates a new Bijection initialized with x mapping to y.\nBijection(dict::Dict{S,T}) creates a new Bijection based on the mapping in dict.\nBijection(pair_list::Vector{Pair{S,T}}) creates a new Bijection using the key/value pairs in pair_list.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.delete!-Tuple{Bijection, Any}","page":"API","title":"Base.delete!","text":"delete!(b::Bijection, x)\n\nDeletes the ordered pair (x,b[x]) from b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.get-Tuple{Bijection, Any, Any}","page":"API","title":"Base.get","text":"get(b::Bijection, key, default)\n\nReturns b[key] if it exists and returns default otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Bijection, Any}","page":"API","title":"Base.getindex","text":"getindex(b::Bijection, x)\n\nFor a Bijection b and a value x in its domain, use b[x] to fetch the image value y associated with x.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Tuple{Bijection, Any}","page":"API","title":"Base.haskey","text":"Base.haskey(b::Bijection, x)\n\nChecks if x is in the domain of the Bijection b.`\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.inv-Tuple{Bijection}","page":"API","title":"Base.inv","text":"inv(b::Bijection)\n\nCreates a new Bijection that is the inverse of b. Subsequence changes to b will not affect inv(b).\n\nSee also active_inv.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isempty-Tuple{Bijection}","page":"API","title":"Base.isempty","text":"isempty(b::Bijection)\n\nReturns true iff b has no pairs.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{Bijection}","page":"API","title":"Base.length","text":"length(b::Bijection)\n\nGives the number of ordered pairs in b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{Bijection, Any, Any}","page":"API","title":"Base.setindex!","text":"setindex!(b::Bijection, y, x)\n\nFor a Bijection b use the syntax b[x]=y to add (x,y) to b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bijections.active_inv-Tuple{Bijection}","page":"API","title":"Bijections.active_inv","text":"active_inv(b::Bijection)\n\nCreates a Bijection that is the inverse of b. The original b and the new Bijection returned are tied together so that changes to one immediately affect the other. In this way, the two Bijections remain inverses in perpetuity.\n\nSee also inv.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bijections.hasvalue-Tuple{Bijection, Any}","page":"API","title":"Bijections.hasvalue","text":"hasvalue(b::Bijection, y)\n\nChecks if y is in the image of the Bijection b. It is equivalent to checking if the inverse mapping b.finv has y as a key, so it should as fast as haskey.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bijections.inverse-Tuple{Bijection, Any}","page":"API","title":"Bijections.inverse","text":"inverse(b::Bijection, y)\n\nReturns the value x such that b[x] == y (if it exists).\n\n\n\n\n\n","category":"method"},{"location":"api/#Bijections.inverse_dict_type-Union{Tuple{Type{<:AbstractDict{K, V}}}, Tuple{V}, Tuple{K}} where {K, V}","page":"API","title":"Bijections.inverse_dict_type","text":"inverse_dict_type(D::Type{<:AbstractDict})\n\nReturns the type of the inverse dictionary for a given AbstractDict type D. This is used internally to create the inverse mapping in a Bijection.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Using-Bijections","page":"Using Bijections","title":"Using Bijections","text":"","category":"section"},{"location":"usage/#Adding-and-deleting-key/value-pairs","page":"Using Bijections","title":"Adding and deleting key/value pairs","text":"Once a Bijection, b, is created, we add a new key-value pair in the same manner as with a Dict:\n\nb = Bijection{Int, String}();\nb[1] = \"hello\"\nb[2] = \"bye\"\n\nNotice, however, that if we add a new key with a value that already exists in the Bijection an error ensues:\n\nb[3] = \"hello\"\n\nOn the contrary, if a key already has a value it can be changed by giving it a new value as long as it doesn't break bijectiveness (i.e. the new value is not already in the Bijection):\n\nb[1] = \"ciao\"","category":"section"},{"location":"usage/#Accessing-values-from-keys,-and-keys-from-values","page":"Using Bijections","title":"Accessing values from keys, and keys from values","text":"To access a value associated with a given key, we use the same syntax as for a Dict:\n\nb[1]\nb[2]\n\nIf the key is not in the Bijection an error is raised:\n\nb[3]\n\nSince the values in a Bijection must be distinct, we can give a value as an input and retrieve its associate key. The function inverse(b,y) finds the value x such that b[x]==y. However, we provide the handy short cut b(y):\n\nb(\"bye\")\nb(\"ciao\")\n\nNaturally, if the requested value is not in the Bijection an error is raised:\n\nb(\"hello\")\n\nIn order to access the domain and image sets of the Bijection, one can use the Base.keys and Base.values functions.\n\nkeys(b)\nvalues(b)\n\nThe collect function returns the Bijection as an array of key-value pairs:\n\ncollect(b)\n\nThe length function returns the number of key-value pairs:\n\nlength(b)\n\nThe isempty function returns true exactly when the Bijection contains no pairs:\n\nisempty(b)","category":"section"},{"location":"#Bijections","page":"Getting Started","title":"Bijections","text":"","category":"section"},{"location":"#Overview","page":"Getting Started","title":"Overview","text":"Mathematically, a bijection is a one-to-one and onto function between sets. In this module, we provide the Bijection data type that represents a bijection between finite collections of objects.\n\nA Dict in Julia is not one-to-one. Two different keys might have the same value. A Bijection data structure behaves just like a Dict except that it prevents assigning the same value to two different keys.","category":"section"},{"location":"#Getting-started","page":"Getting Started","title":"Getting started","text":"After using Bijections we create a new Bijection in one of the following ways:\n\nb = Bijection(): This gives a new Bijection in which the keys and values are of Any type.\nb = Bijection{S,T}(): This gives a new Bijection in which the keys are of type S and the values are of type T.\nb = Bijection(x,y): This gives a new Bijection in which the keys are type typeof(x), the values are type typeof(y) and the key-value pair (x,y) is inserted into the Bijection.\nb = Bijection(dict::AbstractDict{S, T}): This gives a new Bijection in which the keys are type S, the values are type T and all key-value pairs in dict are inserted into the Bijection.\nb = Bijection(pair_list::Vector{Pair{S, T}}): Create a new Bijection using a list of pairs.\n\nSee also the Mutable Objects page for additional constructor options.","category":"section"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations/#Creating-an-inverse-Bijection","page":"Operations","title":"Creating an inverse Bijection","text":"There are two functions that take a Bijection and return a new Bijection that is the functional inverse of the original: inv and active_inv.","category":"section"},{"location":"operations/#Independent-inverse:-inv","page":"Operations","title":"Independent inverse: inv","text":"Given a Bijection b, calling inv(b) creates a new Bijection that is the inverse of b. The new Bijection is completely independent of the original, b. Changes to one do not affect the other:\n\njulia> b = Bijection{Int,String}()\nBijection{Int64, String, Dict{Int64, String}, Dict{String, Int64}}()\n\njulia> b[1] = \"alpha\"\n\"alpha\"\n\njulia> b[2] = \"beta\"\n\"beta\"\n\njulia> bb = inv(b)\nBijection{String, Int64, Dict{String, Int64}, Dict{Int64, String}} with 2 entries:\n  \"alpha\" => 1\n  \"beta\"  => 2\n\njulia> bb[\"alpha\"]\n1\n\njulia> bb[\"alpha\"]\n1\n\njulia> b[3] = \"gamma\"\n\"gamma\"\n\njulia> bb[\"gamma\"]\nERROR: KeyError: key \"gamma\" not found\n[...]","category":"section"},{"location":"operations/#Active-inverse:-active_inv","page":"Operations","title":"Active inverse: active_inv","text":"The active_inv function also creates an inverse Bijection, but in this case the original and the inverse are actively tied together. That is, modification of one immediately affects the other. The two Bijections remain inverses no matter how either is modified.\n\njulia> b = Bijection{Int,String}()\nBijection{Int64, String, Dict{Int64, String}, Dict{String, Int64}}()\n\njulia> b[1] = \"alpha\"\n\"alpha\"\n\njulia> b[2] = \"beta\"\n\"beta\"\n\njulia> bb = active_inv(b)\nBijection{String, Int64, Dict{String, Int64}, Dict{Int64, String}} with 2 entries:\n  \"alpha\" => 1\n  \"beta\"  => 2\n\njulia> b[3] = \"gamma\"\n\"gamma\"\n\njulia> bb[\"gamma\"]\n3","category":"section"},{"location":"operations/#Iteration","page":"Operations","title":"Iteration","text":"Bijections can be used in a for statement just like Julia dictionaries:\n\n# The order of iteration is not guaranteed, so this can't be a doctest # hide\nusing Bijections # hide\nb = Bijection(1 => \"alpha\", 2 => \"beta\", 3 => \"gamma\");\nfor (x, y) in b; println(\"$x --> $y\"); end","category":"section"},{"location":"mutable/#mutable","page":"Mutable Objects","title":"Bijections for Mutable Structures","text":"","category":"section"},{"location":"mutable/#Mutating-keys/values-can-lead-to-corruption","page":"Mutable Objects","title":"Mutating keys/values can lead to corruption","text":"The safest use of a Bijection is when the keys and values  are immutable. If a mutable key or value in a Bijection is altered, the bijective property can be compromised. Here is an example:\n\njulia> b = Bijection{Int, Vector{Int}}();\n\njulia> b[1] = [1,2,3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> b[2] = [1,2,4]\n3-element Vector{Int64}:\n 1\n 2\n 4\n\njulia> b[2][3] = 3\n3\n\njulia> b\nBijection{Int64, Vector{Int64}, Dict{Int64, Vector{Int64}}, Dict{Vector{Int64}, Int64}} with 2 entries:\n  2 => [1, 2, 3]\n  1 => [1, 2, 3]\n\nNotice that b contains a repeated value and therefore is not bijective.\n\nSome strategies to avoid this problem include:\n\nOnly use immutable keys and values (such as numbers and strings).\nUse copies of the keys/values in the Bijection.\nDon't modify keys/values saved in the Bijection.\n\nIn case none of these is a viable option, we provide the following additional alternative.","category":"section"},{"location":"mutable/#Keys/values-as-objects","page":"Mutable Objects","title":"Keys/values as objects","text":"The issue in the example presented above is that distinct Julia objects may be equal, but not the same object. For example:\n\njulia> v = [1,2,3];\n\njulia> w = [1,2,3];\n\njulia> v==w\ntrue\n\njulia> v===w\nfalse\n\nWe may wish to create a Bijection in which the keys or values are permitted to be equal, but are distinct objects. Julia's IdDict is a variation of Dict in which keys/values are considered different if they are distinct object (even if they hold the same data). To replicate this behavior in a Bijection use this longer form constructor:\n\nBijection{K, V, IdDict{K,V}, IdDict{V,K}}()\n\nwhere K is the type of the keys and V is the type of the values.\n\nFor example:\n\njulia> b = Bijection{Vector{Int}, String, IdDict{Vector{Int},String}, IdDict{String,Vector{Int}}}();\n\njulia> b[ [1,2,3] ] = \"alpha\";\n\njulia> b[ [1,2,3] ] = \"beta\";\n\njulia> b(\"alpha\") == b(\"beta\")\ntrue\n\njulia> b(\"alpha\") === b(\"beta\")\nfalse\n\njulia> keys(b)\nKeySet for a IdDict{Vector{Int64}, String} with 2 entries. Keys:\n  [1, 2, 3]\n  [1, 2, 3]\n\njulia> Set(keys(b))\nSet{Vector{Int64}} with 1 element:\n  [1, 2, 3]","category":"section"}]
}

var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following methods constitute the public API of the Bijections package.","category":"page"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Reference","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/#Bijections.Bijection-Tuple{}","page":"API","title":"Bijections.Bijection","text":"Bijection()\n\nConstruct a new Bijection.\n\nBijection{S,T}() creates an empty Bijection from objects of type S to objects of type T. If S and T are omitted, then we have Bijection{Any,Any}.\nBijection(x::S, y::T) creates a new Bijection initialized with x mapping to y.\nBijection(dict::Dict{S,T}) creates a new Bijection based on the mapping in dict.\nBijection(pair_list::Vector{Pair{S,T}}) creates a new Bijection using the key/value pairs in pair_list.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.delete!-Tuple{Bijection, Any}","page":"API","title":"Base.delete!","text":"delete!(b::Bijection, x)\n\nDeletes the ordered pair (x,b[x]) from b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.get-Tuple{Bijection, Any, Any}","page":"API","title":"Base.get","text":"get(b::Bijection, key, default)\n\nReturns b[key] if it exists and returns default otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Bijection, Any}","page":"API","title":"Base.getindex","text":"getindex(b::Bijection, x)\n\nFor a Bijection b and a value x in its domain, use b[x] to fetch the image value y associated with x.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Tuple{Bijection, Any}","page":"API","title":"Base.haskey","text":"Base.haskey(b::Bijection, x)\n\nChecks if x is in the domain of the Bijection b.`\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.inv-Tuple{Bijection}","page":"API","title":"Base.inv","text":"inv(b::Bijection)\n\nCreates a new Bijection that is the inverse of b. Subsequence changes to b will not affect inv(b).\n\nSee also active_inv.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isempty-Tuple{Bijection}","page":"API","title":"Base.isempty","text":"isempty(b::Bijection)\n\nReturns true iff b has no pairs.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{Bijection}","page":"API","title":"Base.length","text":"length(b::Bijection)\n\nGives the number of ordered pairs in b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{Bijection, Any, Any}","page":"API","title":"Base.setindex!","text":"setindex!(b::Bijection, y, x)\n\nFor a Bijection b use the syntax b[x]=y to add (x,y) to b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bijections.active_inv-Tuple{Bijection}","page":"API","title":"Bijections.active_inv","text":"active_inv(b::Bijection)\n\nCreates a Bijection that is the inverse of b. The original b and the new Bijection returned are tied together so that changes to one immediately affect the other. In this way, the two Bijections remain inverses in perpetuity.\n\nSee also inv.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bijections.compose-Union{Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Bijection{B, A}, Bijection{C, B}}} where {A, B, C}","page":"API","title":"Bijections.compose","text":"c = (∘)(a::Bijection{A,B}, b::Bijection{B,C})::Bijection{A,C} where {A,B,C}\nc = compose(a, b)\n\nThe result of a ∘ b or compose(a, b) is a new Bijection c such that c[x] is a[b[x]] for x in the domain of b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bijections.hasvalue-Tuple{Bijection, Any}","page":"API","title":"Bijections.hasvalue","text":"hasvalue(b::Bijection, y)\n\nChecks if y is in the image of the Bijection b. It is equivalent to checking if the inverse mapping b.finv has y as a key, so it should as fast as haskey.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bijections.inverse-Tuple{Bijection, Any}","page":"API","title":"Bijections.inverse","text":"inverse(b::Bijection, y)\n\nReturns the value x such that b[x] == y (if it exists).\n\n\n\n\n\n","category":"method"},{"location":"api/#Bijections.inverse_dict_type-Union{Tuple{Type{<:AbstractDict{K, V}}}, Tuple{V}, Tuple{K}} where {K, V}","page":"API","title":"Bijections.inverse_dict_type","text":"inverse_dict_type(D::Type{<:AbstractDict})\n\nReturns the type of the inverse dictionary for a given AbstractDict type D. This is used internally to create the inverse mapping in a Bijection.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Using-Bijections","page":"Using Bijections","title":"Using Bijections","text":"","category":"section"},{"location":"usage/#Adding-and-deleting-key/value-pairs","page":"Using Bijections","title":"Adding and deleting key/value pairs","text":"","category":"section"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"Once a Bijection, b, is created, we add a new key-value pair in the same manner as with a Dict:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"b = Bijection{Int, String}();\nb[1] = \"hello\"\nb[2] = \"bye\"","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"Notice, however, that if we add a new key with a value that already exists in the Bijection an error ensues:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"b[3] = \"hello\"","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"On the contrary, if a key already has a value it can be changed by giving it a new value as long as it doesn't break bijectiveness (i.e. the new value is not already in the Bijection):","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"b[1] = \"ciao\"","category":"page"},{"location":"usage/#Accessing-values-from-keys,-and-keys-from-values","page":"Using Bijections","title":"Accessing values from keys, and keys from values","text":"","category":"section"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"To access a value associated with a given key, we use the same syntax as for a Dict:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"b[1]\nb[2]","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"If the key is not in the Bijection an error is raised:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"b[3]","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"Since the values in a Bijection must be distinct, we can give a value as an input and retrieve its associate key. The function inverse(b,y) finds the value x such that b[x]==y. However, we provide the handy short cut b(y):","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"b(\"bye\")\nb(\"ciao\")","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"Naturally, if the requested value is not in the Bijection an error is raised:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"b(\"hello\")","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"In order to access the domain and image sets of the Bijection, one can use the Base.keys and Base.values functions.","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"keys(b)\nvalues(b)","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"The collect function returns the Bijection as an array of key-value pairs:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"collect(b)","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"The length function returns the number of key-value pairs:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"length(b)","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"The isempty function returns true exactly when the Bijection contains no pairs:","category":"page"},{"location":"usage/","page":"Using Bijections","title":"Using Bijections","text":"isempty(b)","category":"page"},{"location":"#Bijections","page":"Getting Started","title":"Bijections","text":"","category":"section"},{"location":"#Overview","page":"Getting Started","title":"Overview","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Mathematically, a bijection is a one-to-one and onto function between sets. In this module, we provide the Bijection data type that represents a bijection between finite collections of objects.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"A Dict in Julia is not one-to-one. Two different keys might have the same value. A Bijection data structure behaves just like a Dict except that it prevents assigning the same value to two different keys.","category":"page"},{"location":"#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"After using Bijections we create a new Bijection in one of the following ways:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"b = Bijection(): This gives a new Bijection in which the keys and values are of Any type.\nb = Bijection{S,T}(): This gives a new Bijection in which the keys are of type S and the values are of type T.\nb = Bijection(x,y): This gives a new Bijection in which the keys are type typeof(x), the values are type typeof(y) and the key-value pair (x,y) is inserted into the Bijection.\nb = Bijection(dict::AbstractDict{S, T}): This gives a new Bijection in which the keys are type S, the values are type T and all key-value pairs in dict are inserted into the Bijection.\nb = Bijection(pair_list::Vector{Pair{S, T}}): Create a new Bijection using a list of pairs.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"See also the Mutable Objects page for additional constructor options.","category":"page"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations/#Creating-an-inverse-Bijection","page":"Operations","title":"Creating an inverse Bijection","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"There are two functions that take a Bijection and return a new Bijection that is the functional inverse of the original: inv and active_inv.","category":"page"},{"location":"operations/#Independent-inverse:-inv","page":"Operations","title":"Independent inverse: inv","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Given a Bijection b, calling inv(b) creates a new Bijection that is the inverse of b. The new Bijection is completely independent of the original, b. Changes to one do not affect the other:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> b = Bijection{Int,String}()\nBijection{Int64, String, Dict{Int64, String}, Dict{String, Int64}}()\n\njulia> b[1] = \"alpha\"\n\"alpha\"\n\njulia> b[2] = \"beta\"\n\"beta\"\n\njulia> bb = inv(b)\nBijection{String, Int64, Dict{String, Int64}, Dict{Int64, String}} with 2 entries:\n  \"alpha\" => 1\n  \"beta\"  => 2\n\njulia> bb[\"alpha\"]\n1\n\njulia> bb[\"alpha\"]\n1\n\njulia> b[3] = \"gamma\"\n\"gamma\"\n\njulia> bb[\"gamma\"]\nERROR: KeyError: key \"gamma\" not found\n[...]","category":"page"},{"location":"operations/#Active-inverse:-active_inv","page":"Operations","title":"Active inverse: active_inv","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The active_inv function also creates an inverse Bijection, but in this case the original and the inverse are actively tied together. That is, modification of one immediately affects the other. The two Bijections remain inverses no matter how either is modified.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> b = Bijection{Int,String}()\nBijection{Int64, String, Dict{Int64, String}, Dict{String, Int64}}()\n\njulia> b[1] = \"alpha\"\n\"alpha\"\n\njulia> b[2] = \"beta\"\n\"beta\"\n\njulia> bb = active_inv(b)\nBijection{String, Int64, Dict{String, Int64}, Dict{Int64, String}} with 2 entries:\n  \"alpha\" => 1\n  \"beta\"  => 2\n\njulia> b[3] = \"gamma\"\n\"gamma\"\n\njulia> bb[\"gamma\"]\n3","category":"page"},{"location":"operations/#Iteration","page":"Operations","title":"Iteration","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Bijections can be used in a for statement just like Julia dictionaries:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"# The order of iteration is not guaranteed, so this can't be a doctest # hide\nusing Bijections # hide\nb = Bijection(1 => \"alpha\", 2 => \"beta\", 3 => \"gamma\");\nfor (x, y) in b; println(\"$x --> $y\"); end","category":"page"},{"location":"operations/#Composition","page":"Operations","title":"Composition","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Given two Bijections a and b, their composition c = a ∘ b or c = compose(a, b) is a new Bijection with the property that c[x] = a[b[x]] for all x in the domain of b.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> a = Bijection{Int,Int}(1 => 10, 2 => 20);\n\njulia> b = Bijection{String,Int}(\"hi\" => 1, \"bye\" => 2);\n\njulia> c = a ∘ b;\n\njulia> c[\"hi\"]\n10","category":"page"},{"location":"mutable/#mutable","page":"Mutable Objects","title":"Bijections for Mutable Structures","text":"","category":"section"},{"location":"mutable/#Mutating-keys/values-can-lead-to-corruption","page":"Mutable Objects","title":"Mutating keys/values can lead to corruption","text":"","category":"section"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"The safest use of a Bijection is when the keys and values  are immutable. If a mutable key or value in a Bijection is altered, the bijective property can be compromised. Here is an example:","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"julia> b = Bijection{Int, Vector{Int}}();\n\njulia> b[1] = [1,2,3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> b[2] = [1,2,4]\n3-element Vector{Int64}:\n 1\n 2\n 4\n\njulia> b[2][3] = 3\n3\n\njulia> b\nBijection{Int64, Vector{Int64}, Dict{Int64, Vector{Int64}}, Dict{Vector{Int64}, Int64}} with 2 entries:\n  2 => [1, 2, 3]\n  1 => [1, 2, 3]","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"Notice that b contains a repeated value and therefore is not bijective.","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"Some strategies to avoid this problem include:","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"Only use immutable keys and values (such as numbers and strings).\nUse copies of the keys/values in the Bijection.\nDon't modify keys/values saved in the Bijection.","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"In case none of these is a viable option, we provide the following additional alternative.","category":"page"},{"location":"mutable/#Keys/values-as-objects","page":"Mutable Objects","title":"Keys/values as objects","text":"","category":"section"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"The issue in the example presented above is that distinct Julia objects may be equal, but not the same object. For example:","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"julia> v = [1,2,3];\n\njulia> w = [1,2,3];\n\njulia> v==w\ntrue\n\njulia> v===w\nfalse","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"We may wish to create a Bijection in which the keys or values are permitted to be equal, but are distinct objects. Julia's IdDict is a variation of Dict in which keys/values are considered different if they are distinct object (even if they hold the same data). To replicate this behavior in a Bijection use this longer form constructor:","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"Bijection{K, V, IdDict{K,V}, IdDict{V,K}}()","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"where K is the type of the keys and V is the type of the values.","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"For example:","category":"page"},{"location":"mutable/","page":"Mutable Objects","title":"Mutable Objects","text":"julia> b = Bijection{Vector{Int}, String, IdDict{Vector{Int},String}, IdDict{String,Vector{Int}}}();\n\njulia> b[ [1,2,3] ] = \"alpha\";\n\njulia> b[ [1,2,3] ] = \"beta\";\n\njulia> b(\"alpha\") == b(\"beta\")\ntrue\n\njulia> b(\"alpha\") === b(\"beta\")\nfalse\n\njulia> keys(b)\nKeySet for a IdDict{Vector{Int64}, String} with 2 entries. Keys:\n  [1, 2, 3]\n  [1, 2, 3]\n\njulia> Set(keys(b))\nSet{Vector{Int64}} with 1 element:\n  [1, 2, 3]","category":"page"}]
}
